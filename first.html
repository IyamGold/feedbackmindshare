<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Onchain Snake Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            padding: 20px;
        }

        header {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: #764ba2;
            font-size: 2rem;
        }

        .wallet-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .btn-connect {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: transform 0.2s;
        }

        .btn-connect:hover {
            transform: scale(1.05);
        }

        .wallet-address {
            font-family: monospace;
            color: #666;
        }

        main {
            display: flex;
            gap: 20px;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            flex: 1;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .game-info {
            margin-bottom: 20px;
        }

        .score-board {
            display: flex;
            justify-content: space-around;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .current-score {
            color: #667eea;
        }

        .high-score {
            color: #764ba2;
        }

        #gameCanvas {
            border: 2px solid #333;
            border-radius: 5px;
            display: block;
            margin: 0 auto;
            background: #f0f0f0;
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }

        .btn-game {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.3s;
        }

        .btn-game:hover:not(:disabled) {
            background: #764ba2;
        }

        .btn-game:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .instructions {
            margin-top: 20px;
            padding: 15px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 5px;
        }

        .instructions h3 {
            color: #764ba2;
            margin-bottom: 10px;
        }

        .instructions p {
            margin: 5px 0;
            color: #666;
        }

        .leaderboard {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            padding: 20px;
            width: 300px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .leaderboard h2 {
            color: #764ba2;
            margin-bottom: 15px;
            text-align: center;
        }

        .leaderboard-list {
            max-height: 500px;
            overflow-y: auto;
        }

        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid #eee;
            transition: background 0.2s;
        }

        .leaderboard-item:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .leaderboard-rank {
            font-weight: bold;
            color: #667eea;
            min-width: 30px;
        }

        .leaderboard-player {
            flex: 1;
            color: #666;
        }

        .leaderboard-score {
            font-weight: bold;
            color: #764ba2;
        }

        @media (max-width: 768px) {
            main {
                flex-direction: column;
            }

            .leaderboard {
                width: 100%;
            }

            #gameCanvas {
                width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Onchain Snake Game</h1>
            <div class="wallet-section">
                <button id="connectWallet" class="btn-connect">Connect Wallet</button>
                <span id="walletAddress" class="wallet-address"></span>
            </div>
        </header>

        <main>
            <div class="game-container">
                <div class="game-info">
                    <div class="score-board">
                        <div class="current-score">
                            <span>Score: </span>
                            <span id="score">0</span>
                        </div>
                        <div class="high-score">
                            <span>High Score: </span>
                            <span id="highScore">0</span>
                        </div>
                    </div>
                </div>

                <canvas id="gameCanvas" width="600" height="600"></canvas>

                <div class="game-controls">
                    <button id="startGame" class="btn-game">Start Game</button>
                    <button id="pauseGame" class="btn-game" disabled>Pause</button>
                    <button id="submitScore" class="btn-game" disabled>Submit Score to Chain</button>
                </div>

                <div class="instructions">
                    <h3>How to Play</h3>
                    <p>Use arrow keys to control the snake</p>
                    <p>Eat the red food to grow and increase your score</p>
                    <p>Don't hit the walls or yourself!</p>
                </div>
            </div>

            <aside class="leaderboard">
                <h2>Leaderboard</h2>
                <div id="leaderboardList" class="leaderboard-list">
                    <div class="leaderboard-item">
                        <span class="leaderboard-rank">1.</span>
                        <span class="leaderboard-player">Player 1</span>
                        <span class="leaderboard-score">500</span>
                    </div>
                    <div class="leaderboard-item">
                        <span class="leaderboard-rank">2.</span>
                        <span class="leaderboard-player">Player 2</span>
                        <span class="leaderboard-score">450</span>
                    </div>
                    <div class="leaderboard-item">
                        <span class="leaderboard-rank">3.</span>
                        <span class="leaderboard-player">Player 3</span>
                        <span class="leaderboard-score">400</span>
                    </div>
                </div>
            </aside>
        </main>
    </div>

    <script>
        // Snake Game Class
        class SnakeGame {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.gridSize = 20;
                this.tileCount = this.canvas.width / this.gridSize;

                this.reset();
            }

            reset() {
                this.snake = [
                    {x: 10, y: 10}
                ];
                this.direction = {x: 0, y: 0};
                this.food = this.generateFood();
                this.score = 0;
                this.gameOver = false;
                this.isPaused = false;
            }

            generateFood() {
                let newFood;
                do {
                    newFood = {
                        x: Math.floor(Math.random() * this.tileCount),
                        y: Math.floor(Math.random() * this.tileCount)
                    };
                } while (this.snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));

                return newFood;
            }

            update() {
                if (this.gameOver || this.isPaused) return;

                // Move snake head
                const head = {x: this.snake[0].x + this.direction.x, y: this.snake[0].y + this.direction.y};

                // Check wall collision
                if (head.x < 0 || head.x >= this.tileCount || head.y < 0 || head.y >= this.tileCount) {
                    this.gameOver = true;
                    return;
                }

                // Check self collision
                if (this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                    this.gameOver = true;
                    return;
                }

                this.snake.unshift(head);

                // Check food collision
                if (head.x === this.food.x && head.y === this.food.y) {
                    this.score += 10;
                    this.food = this.generateFood();
                    document.getElementById('score').textContent = this.score;

                    // Update high score
                    const currentHighScore = parseInt(document.getElementById('highScore').textContent);
                    if (this.score > currentHighScore) {
                        document.getElementById('highScore').textContent = this.score;
                        localStorage.setItem('highScore', this.score);
                    }
                } else {
                    this.snake.pop();
                }
            }

            draw() {
                // Clear canvas
                this.ctx.fillStyle = '#f0f0f0';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw grid
                this.ctx.strokeStyle = '#ddd';
                this.ctx.lineWidth = 0.5;
                for (let i = 0; i <= this.tileCount; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i * this.gridSize, 0);
                    this.ctx.lineTo(i * this.gridSize, this.canvas.height);
                    this.ctx.stroke();

                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i * this.gridSize);
                    this.ctx.lineTo(this.canvas.width, i * this.gridSize);
                    this.ctx.stroke();
                }

                // Draw snake
                this.snake.forEach((segment, index) => {
                    this.ctx.fillStyle = index === 0 ? '#667eea' : '#764ba2';
                    this.ctx.fillRect(segment.x * this.gridSize + 2, segment.y * this.gridSize + 2,
                                    this.gridSize - 4, this.gridSize - 4);
                });

                // Draw food
                this.ctx.fillStyle = '#ff6b6b';
                this.ctx.beginPath();
                this.ctx.arc(this.food.x * this.gridSize + this.gridSize/2,
                            this.food.y * this.gridSize + this.gridSize/2,
                            this.gridSize/3, 0, Math.PI * 2);
                this.ctx.fill();

                // Draw game over message
                if (this.gameOver) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 48px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('GAME OVER', this.canvas.width/2, this.canvas.height/2 - 20);

                    this.ctx.font = '24px Arial';
                    this.ctx.fillText(`Final Score: ${this.score}`, this.canvas.width/2, this.canvas.height/2 + 20);

                    // Enable submit score button if game is over with a score
                    if (this.score > 0) {
                        document.getElementById('submitScore').disabled = false;
                    }
                }

                // Draw pause message
                if (this.isPaused && !this.gameOver) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    this.ctx.fillStyle = 'white';
                    this.ctx.font = 'bold 48px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('PAUSED', this.canvas.width/2, this.canvas.height/2);
                }
            }

            changeDirection(newDirection) {
                if (this.gameOver || this.direction.x === 0 && this.direction.y === 0) {
                    this.direction = newDirection;
                    return;
                }

                // Prevent reverse direction
                if (newDirection.x !== 0 && this.direction.x === 0) {
                    this.direction = newDirection;
                } else if (newDirection.y !== 0 && this.direction.y === 0) {
                    this.direction = newDirection;
                }
            }

            togglePause() {
                if (!this.gameOver) {
                    this.isPaused = !this.isPaused;
                    document.getElementById('pauseGame').textContent = this.isPaused ? 'Resume' : 'Pause';
                }
            }

            start() {
                this.reset();
                this.direction = {x: 1, y: 0};
                document.getElementById('startGame').textContent = 'Restart';
                document.getElementById('pauseGame').disabled = false;
                document.getElementById('submitScore').disabled = true;
            }
        }

        // Initialize game
        const canvas = document.getElementById('gameCanvas');
        const game = new SnakeGame(canvas);
        let gameLoop;

        // Load high score from localStorage
        const savedHighScore = localStorage.getItem('highScore') || 0;
        document.getElementById('highScore').textContent = savedHighScore;

        // Game controls
        document.getElementById('startGame').addEventListener('click', () => {
            game.start();
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(() => {
                game.update();
                game.draw();
            }, 100);
        });

        document.getElementById('pauseGame').addEventListener('click', () => {
            game.togglePause();
        });

        document.getElementById('submitScore').addEventListener('click', async () => {
            if (!window.ethereum) {
                alert('Please install MetaMask to submit scores to blockchain!');
                return;
            }

            try {
                // Check network first
                const chainId = await window.ethereum.request({ method: 'eth_chainId' });
                const currentChainId = parseInt(chainId, 16);

                if (currentChainId !== 20994) {
                    alert('Please switch to Fluent Testnet (Chain ID: 20994) to submit your score!');

                    // Try to switch network
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0x5222' }], // 20994 in hex
                        });
                    } catch (switchError) {
                        console.error('Failed to switch network:', switchError);
                    }
                    return;
                }

                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                if (accounts.length === 0) {
                    alert('Please connect your wallet first!');
                    return;
                }

                document.getElementById('submitScore').textContent = 'Submitting...';
                document.getElementById('submitScore').disabled = true;

                // Contract configuration
                const contractAddress = "0x4B4765d1A375f8f96cE99Ea966766dB34a8d6c09";

                // Encode the function call manually
                // Function selector for submitScore(uint256)
                const functionSelector = '0xdf218937'; // keccak256("submitScore(uint256)")
                const scoreHex = game.score.toString(16).padStart(64, '0');
                const data = functionSelector + scoreHex;

                // Send transaction
                const tx = await window.ethereum.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        from: accounts[0],
                        to: contractAddress,
                        data: data,
                        gas: '0x30000' // 196608 gas limit
                    }]
                });

                console.log('Transaction sent:', tx);
                alert(`Score submission sent! Transaction: ${tx.substring(0, 10)}...`);

                // Also save score locally
                const localScores = JSON.parse(localStorage.getItem('leaderboardScores') || '[]');
                localScores.push({
                    player: accounts[0].substring(0, 6) + '...' + accounts[0].substring(accounts[0].length - 4),
                    score: game.score,
                    timestamp: Date.now()
                });
                localStorage.setItem('leaderboardScores', JSON.stringify(localScores));

                // Note: Without ethers, we can't easily wait for confirmation
                // The transaction will process in the background

                setTimeout(() => {
                    loadLeaderboard();
                }, 2000); // Refresh leaderboard after 2 seconds

            } catch (error) {
                console.error('Error submitting score:', error);
                alert(`Failed to submit score: ${error.message}`);
            } finally {
                document.getElementById('submitScore').textContent = 'Submit Score to Chain';
                document.getElementById('submitScore').disabled = false;
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    game.changeDirection({x: 0, y: -1});
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    game.changeDirection({x: 0, y: 1});
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    game.changeDirection({x: -1, y: 0});
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    game.changeDirection({x: 1, y: 0});
                    break;
                case ' ':
                    e.preventDefault();
                    if (game.direction.x !== 0 || game.direction.y !== 0) {
                        game.togglePause();
                    }
                    break;
            }
        });

        // Load leaderboard from blockchain
        async function loadLeaderboard() {
            // For now, we'll display sample data since reading contract data
            // without ethers.js requires complex encoding/decoding
            // You can integrate ethers.js later for full blockchain functionality

            const leaderboardElement = document.getElementById('leaderboardList');

            // Check if we have any locally stored scores
            const localScores = JSON.parse(localStorage.getItem('leaderboardScores') || '[]');

            if (localScores.length === 0) {
                leaderboardElement.innerHTML = '<div class="loading">No scores yet. Be the first!</div>';
                return;
            }

            leaderboardElement.innerHTML = '';
            localScores.sort((a, b) => b.score - a.score);

            localScores.slice(0, 10).forEach((entry, index) => {
                const item = document.createElement('div');
                item.className = 'leaderboard-item';

                item.innerHTML = `
                    <span class="leaderboard-rank">${index + 1}.</span>
                    <span class="leaderboard-player">${entry.player}</span>
                    <span class="leaderboard-score">${entry.score}</span>
                `;

                leaderboardElement.appendChild(item);
            });
        }

        // Function to detect MetaMask with multiple methods
        function isMetaMaskInstalled() {
            // Method 1: Check for ethereum object
            if (typeof window.ethereum !== 'undefined' && window.ethereum.isMetaMask) {
                return true;
            }

            // Method 2: Check for legacy web3
            if (typeof window.web3 !== 'undefined' && window.web3.currentProvider && window.web3.currentProvider.isMetaMask) {
                return true;
            }

            // Method 3: Check for MetaMask in providers array (newer versions)
            if (window.ethereum?.providers?.length > 0) {
                return window.ethereum.providers.some(provider => provider.isMetaMask);
            }

            return false;
        }

        // Get ethereum provider
        function getEthereumProvider() {
            if (window.ethereum?.isMetaMask) {
                return window.ethereum;
            }

            if (window.ethereum?.providers?.length > 0) {
                const metaMaskProvider = window.ethereum.providers.find(provider => provider.isMetaMask);
                if (metaMaskProvider) return metaMaskProvider;
            }

            return window.ethereum;
        }

        // Wallet connection
        document.getElementById('connectWallet').addEventListener('click', async () => {
            console.log('Connect wallet clicked');
            console.log('window.ethereum:', window.ethereum);
            console.log('window.web3:', window.web3);
            console.log('isMetaMask:', window.ethereum?.isMetaMask);
            console.log('providers:', window.ethereum?.providers);

            // Wait a bit for MetaMask to load if needed
            await new Promise(resolve => setTimeout(resolve, 100));

            if (isMetaMaskInstalled()) {
                const provider = getEthereumProvider();
                console.log('Using provider:', provider);
                try {
                    // Request account access
                    const accounts = await provider.request({ method: 'eth_requestAccounts' });
                    console.log('Accounts:', accounts);
                    const account = accounts[0];

                    // Display connected address
                    document.getElementById('walletAddress').textContent =
                        account.substring(0, 6) + '...' + account.substring(account.length - 4);
                    document.getElementById('connectWallet').textContent = 'Connected';
                    document.getElementById('connectWallet').disabled = true;

                    // Store connected address for local leaderboard
                    window.connectedAccount = account;

                    // Load leaderboard after connecting
                    await loadLeaderboard();
                } catch (error) {
                    console.error('Failed to connect wallet:', error);
                    alert('Failed to connect wallet. Please try again.');
                }
            } else {
                console.log('MetaMask not detected');
                alert('MetaMask not detected!\n\nPlease:\n1. Install MetaMask extension\n2. Make sure it\'s enabled\n3. Refresh the page\n4. Try opening the file in a new tab');
            }
        });

        // Initial draw
        game.draw();

        // Wait for page and MetaMask to load completely
        window.addEventListener('load', () => {
            setTimeout(() => {
                console.log('Page loaded, checking for MetaMask...');
                console.log('window.ethereum after load:', window.ethereum);
                if (isMetaMaskInstalled()) {
                    loadLeaderboard();
                    console.log('MetaMask detected on page load');
                } else {
                    console.log('MetaMask not detected on page load');
                }
            }, 2000);
        });
    </script>
</body>
</html>
